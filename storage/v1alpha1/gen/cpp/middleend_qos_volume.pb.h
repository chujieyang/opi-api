// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: middleend_qos_volume.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_middleend_5fqos_5fvolume_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_middleend_5fqos_5fvolume_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "opicommon.pb.h"
#include "google/api/client.pb.h"
#include "google/api/resource.pb.h"
#include <google/protobuf/empty.pb.h>
#include "google/api/annotations.pb.h"
#include "google/api/field_behavior.pb.h"
#include <google/protobuf/field_mask.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_middleend_5fqos_5fvolume_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_middleend_5fqos_5fvolume_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_middleend_5fqos_5fvolume_2eproto;
namespace opi_api {
namespace storage {
namespace v1 {
class CreateQosVolumeRequest;
struct CreateQosVolumeRequestDefaultTypeInternal;
extern CreateQosVolumeRequestDefaultTypeInternal _CreateQosVolumeRequest_default_instance_;
class DeleteQosVolumeRequest;
struct DeleteQosVolumeRequestDefaultTypeInternal;
extern DeleteQosVolumeRequestDefaultTypeInternal _DeleteQosVolumeRequest_default_instance_;
class GetQosVolumeRequest;
struct GetQosVolumeRequestDefaultTypeInternal;
extern GetQosVolumeRequestDefaultTypeInternal _GetQosVolumeRequest_default_instance_;
class Limits;
struct LimitsDefaultTypeInternal;
extern LimitsDefaultTypeInternal _Limits_default_instance_;
class ListQosVolumesRequest;
struct ListQosVolumesRequestDefaultTypeInternal;
extern ListQosVolumesRequestDefaultTypeInternal _ListQosVolumesRequest_default_instance_;
class ListQosVolumesResponse;
struct ListQosVolumesResponseDefaultTypeInternal;
extern ListQosVolumesResponseDefaultTypeInternal _ListQosVolumesResponse_default_instance_;
class QosVolume;
struct QosVolumeDefaultTypeInternal;
extern QosVolumeDefaultTypeInternal _QosVolume_default_instance_;
class StatsQosVolumeRequest;
struct StatsQosVolumeRequestDefaultTypeInternal;
extern StatsQosVolumeRequestDefaultTypeInternal _StatsQosVolumeRequest_default_instance_;
class StatsQosVolumeResponse;
struct StatsQosVolumeResponseDefaultTypeInternal;
extern StatsQosVolumeResponseDefaultTypeInternal _StatsQosVolumeResponse_default_instance_;
class UpdateQosVolumeRequest;
struct UpdateQosVolumeRequestDefaultTypeInternal;
extern UpdateQosVolumeRequestDefaultTypeInternal _UpdateQosVolumeRequest_default_instance_;
}  // namespace v1
}  // namespace storage
}  // namespace opi_api
PROTOBUF_NAMESPACE_OPEN
template<> ::opi_api::storage::v1::CreateQosVolumeRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::CreateQosVolumeRequest>(Arena*);
template<> ::opi_api::storage::v1::DeleteQosVolumeRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::DeleteQosVolumeRequest>(Arena*);
template<> ::opi_api::storage::v1::GetQosVolumeRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::GetQosVolumeRequest>(Arena*);
template<> ::opi_api::storage::v1::Limits* Arena::CreateMaybeMessage<::opi_api::storage::v1::Limits>(Arena*);
template<> ::opi_api::storage::v1::ListQosVolumesRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListQosVolumesRequest>(Arena*);
template<> ::opi_api::storage::v1::ListQosVolumesResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::ListQosVolumesResponse>(Arena*);
template<> ::opi_api::storage::v1::QosVolume* Arena::CreateMaybeMessage<::opi_api::storage::v1::QosVolume>(Arena*);
template<> ::opi_api::storage::v1::StatsQosVolumeRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsQosVolumeRequest>(Arena*);
template<> ::opi_api::storage::v1::StatsQosVolumeResponse* Arena::CreateMaybeMessage<::opi_api::storage::v1::StatsQosVolumeResponse>(Arena*);
template<> ::opi_api::storage::v1::UpdateQosVolumeRequest* Arena::CreateMaybeMessage<::opi_api::storage::v1::UpdateQosVolumeRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace opi_api {
namespace storage {
namespace v1 {

// ===================================================================

class QosVolume final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.QosVolume) */ {
 public:
  inline QosVolume() : QosVolume(nullptr) {}
  ~QosVolume() override;
  explicit PROTOBUF_CONSTEXPR QosVolume(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QosVolume(const QosVolume& from);
  QosVolume(QosVolume&& from) noexcept
    : QosVolume() {
    *this = ::std::move(from);
  }

  inline QosVolume& operator=(const QosVolume& from) {
    CopyFrom(from);
    return *this;
  }
  inline QosVolume& operator=(QosVolume&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QosVolume& default_instance() {
    return *internal_default_instance();
  }
  static inline const QosVolume* internal_default_instance() {
    return reinterpret_cast<const QosVolume*>(
               &_QosVolume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(QosVolume& a, QosVolume& b) {
    a.Swap(&b);
  }
  inline void Swap(QosVolume* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QosVolume* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QosVolume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QosVolume>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QosVolume& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QosVolume& from) {
    QosVolume::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QosVolume* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.QosVolume";
  }
  protected:
  explicit QosVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVolumeNameRefFieldNumber = 2,
    kLimitsFieldNumber = 3,
  };
  // string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string volume_name_ref = 2 [(.google.api.field_behavior) = REQUIRED];
  void clear_volume_name_ref();
  const std::string& volume_name_ref() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_volume_name_ref(ArgT0&& arg0, ArgT... args);
  std::string* mutable_volume_name_ref();
  PROTOBUF_NODISCARD std::string* release_volume_name_ref();
  void set_allocated_volume_name_ref(std::string* volume_name_ref);
  private:
  const std::string& _internal_volume_name_ref() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_volume_name_ref(const std::string& value);
  std::string* _internal_mutable_volume_name_ref();
  public:

  // .opi_api.storage.v1.Limits limits = 3 [(.google.api.field_behavior) = REQUIRED];
  bool has_limits() const;
  private:
  bool _internal_has_limits() const;
  public:
  void clear_limits();
  const ::opi_api::storage::v1::Limits& limits() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::Limits* release_limits();
  ::opi_api::storage::v1::Limits* mutable_limits();
  void set_allocated_limits(::opi_api::storage::v1::Limits* limits);
  private:
  const ::opi_api::storage::v1::Limits& _internal_limits() const;
  ::opi_api::storage::v1::Limits* _internal_mutable_limits();
  public:
  void unsafe_arena_set_allocated_limits(
      ::opi_api::storage::v1::Limits* limits);
  ::opi_api::storage::v1::Limits* unsafe_arena_release_limits();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.QosVolume)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_name_ref_;
    ::opi_api::storage::v1::Limits* limits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class Limits final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.Limits) */ {
 public:
  inline Limits() : Limits(nullptr) {}
  ~Limits() override;
  explicit PROTOBUF_CONSTEXPR Limits(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Limits(const Limits& from);
  Limits(Limits&& from) noexcept
    : Limits() {
    *this = ::std::move(from);
  }

  inline Limits& operator=(const Limits& from) {
    CopyFrom(from);
    return *this;
  }
  inline Limits& operator=(Limits&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Limits& default_instance() {
    return *internal_default_instance();
  }
  static inline const Limits* internal_default_instance() {
    return reinterpret_cast<const Limits*>(
               &_Limits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Limits& a, Limits& b) {
    a.Swap(&b);
  }
  inline void Swap(Limits* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Limits* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Limits* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Limits>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Limits& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Limits& from) {
    Limits::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Limits* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.Limits";
  }
  protected:
  explicit Limits(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // .opi_api.storage.v1.QosLimit min = 1 [(.google.api.field_behavior) = OPTIONAL];
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  const ::opi_api::storage::v1::QosLimit& min() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::QosLimit* release_min();
  ::opi_api::storage::v1::QosLimit* mutable_min();
  void set_allocated_min(::opi_api::storage::v1::QosLimit* min);
  private:
  const ::opi_api::storage::v1::QosLimit& _internal_min() const;
  ::opi_api::storage::v1::QosLimit* _internal_mutable_min();
  public:
  void unsafe_arena_set_allocated_min(
      ::opi_api::storage::v1::QosLimit* min);
  ::opi_api::storage::v1::QosLimit* unsafe_arena_release_min();

  // .opi_api.storage.v1.QosLimit max = 2 [(.google.api.field_behavior) = OPTIONAL];
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const ::opi_api::storage::v1::QosLimit& max() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::QosLimit* release_max();
  ::opi_api::storage::v1::QosLimit* mutable_max();
  void set_allocated_max(::opi_api::storage::v1::QosLimit* max);
  private:
  const ::opi_api::storage::v1::QosLimit& _internal_max() const;
  ::opi_api::storage::v1::QosLimit* _internal_mutable_max();
  public:
  void unsafe_arena_set_allocated_max(
      ::opi_api::storage::v1::QosLimit* max);
  ::opi_api::storage::v1::QosLimit* unsafe_arena_release_max();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.Limits)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::QosLimit* min_;
    ::opi_api::storage::v1::QosLimit* max_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class CreateQosVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.CreateQosVolumeRequest) */ {
 public:
  inline CreateQosVolumeRequest() : CreateQosVolumeRequest(nullptr) {}
  ~CreateQosVolumeRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateQosVolumeRequest(const CreateQosVolumeRequest& from);
  CreateQosVolumeRequest(CreateQosVolumeRequest&& from) noexcept
    : CreateQosVolumeRequest() {
    *this = ::std::move(from);
  }

  inline CreateQosVolumeRequest& operator=(const CreateQosVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateQosVolumeRequest& operator=(CreateQosVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateQosVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateQosVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const CreateQosVolumeRequest*>(
               &_CreateQosVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateQosVolumeRequest& a, CreateQosVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateQosVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateQosVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateQosVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateQosVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateQosVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateQosVolumeRequest& from) {
    CreateQosVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateQosVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.CreateQosVolumeRequest";
  }
  protected:
  explicit CreateQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQosVolumeIdFieldNumber = 2,
    kQosVolumeFieldNumber = 1,
  };
  // string qos_volume_id = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_qos_volume_id();
  const std::string& qos_volume_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_qos_volume_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_qos_volume_id();
  PROTOBUF_NODISCARD std::string* release_qos_volume_id();
  void set_allocated_qos_volume_id(std::string* qos_volume_id);
  private:
  const std::string& _internal_qos_volume_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qos_volume_id(const std::string& value);
  std::string* _internal_mutable_qos_volume_id();
  public:

  // .opi_api.storage.v1.QosVolume qos_volume = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_qos_volume() const;
  private:
  bool _internal_has_qos_volume() const;
  public:
  void clear_qos_volume();
  const ::opi_api::storage::v1::QosVolume& qos_volume() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::QosVolume* release_qos_volume();
  ::opi_api::storage::v1::QosVolume* mutable_qos_volume();
  void set_allocated_qos_volume(::opi_api::storage::v1::QosVolume* qos_volume);
  private:
  const ::opi_api::storage::v1::QosVolume& _internal_qos_volume() const;
  ::opi_api::storage::v1::QosVolume* _internal_mutable_qos_volume();
  public:
  void unsafe_arena_set_allocated_qos_volume(
      ::opi_api::storage::v1::QosVolume* qos_volume);
  ::opi_api::storage::v1::QosVolume* unsafe_arena_release_qos_volume();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.CreateQosVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qos_volume_id_;
    ::opi_api::storage::v1::QosVolume* qos_volume_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class DeleteQosVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.DeleteQosVolumeRequest) */ {
 public:
  inline DeleteQosVolumeRequest() : DeleteQosVolumeRequest(nullptr) {}
  ~DeleteQosVolumeRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteQosVolumeRequest(const DeleteQosVolumeRequest& from);
  DeleteQosVolumeRequest(DeleteQosVolumeRequest&& from) noexcept
    : DeleteQosVolumeRequest() {
    *this = ::std::move(from);
  }

  inline DeleteQosVolumeRequest& operator=(const DeleteQosVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteQosVolumeRequest& operator=(DeleteQosVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteQosVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteQosVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteQosVolumeRequest*>(
               &_DeleteQosVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeleteQosVolumeRequest& a, DeleteQosVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteQosVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteQosVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteQosVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteQosVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteQosVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteQosVolumeRequest& from) {
    DeleteQosVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteQosVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.DeleteQosVolumeRequest";
  }
  protected:
  explicit DeleteQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAllowMissingFieldNumber = 2,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.DeleteQosVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class UpdateQosVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.UpdateQosVolumeRequest) */ {
 public:
  inline UpdateQosVolumeRequest() : UpdateQosVolumeRequest(nullptr) {}
  ~UpdateQosVolumeRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateQosVolumeRequest(const UpdateQosVolumeRequest& from);
  UpdateQosVolumeRequest(UpdateQosVolumeRequest&& from) noexcept
    : UpdateQosVolumeRequest() {
    *this = ::std::move(from);
  }

  inline UpdateQosVolumeRequest& operator=(const UpdateQosVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateQosVolumeRequest& operator=(UpdateQosVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateQosVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateQosVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateQosVolumeRequest*>(
               &_UpdateQosVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UpdateQosVolumeRequest& a, UpdateQosVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateQosVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateQosVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateQosVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateQosVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateQosVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateQosVolumeRequest& from) {
    UpdateQosVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateQosVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.UpdateQosVolumeRequest";
  }
  protected:
  explicit UpdateQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQosVolumeFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
    kAllowMissingFieldNumber = 3,
  };
  // .opi_api.storage.v1.QosVolume qos_volume = 1 [(.google.api.field_behavior) = REQUIRED];
  bool has_qos_volume() const;
  private:
  bool _internal_has_qos_volume() const;
  public:
  void clear_qos_volume();
  const ::opi_api::storage::v1::QosVolume& qos_volume() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::QosVolume* release_qos_volume();
  ::opi_api::storage::v1::QosVolume* mutable_qos_volume();
  void set_allocated_qos_volume(::opi_api::storage::v1::QosVolume* qos_volume);
  private:
  const ::opi_api::storage::v1::QosVolume& _internal_qos_volume() const;
  ::opi_api::storage::v1::QosVolume* _internal_mutable_qos_volume();
  public:
  void unsafe_arena_set_allocated_qos_volume(
      ::opi_api::storage::v1::QosVolume* qos_volume);
  ::opi_api::storage::v1::QosVolume* unsafe_arena_release_qos_volume();

  // .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
  bool has_update_mask() const;
  private:
  bool _internal_has_update_mask() const;
  public:
  void clear_update_mask();
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::FieldMask* release_update_mask();
  ::PROTOBUF_NAMESPACE_ID::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  private:
  const ::PROTOBUF_NAMESPACE_ID::FieldMask& _internal_update_mask() const;
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _internal_mutable_update_mask();
  public:
  void unsafe_arena_set_allocated_update_mask(
      ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask);
  ::PROTOBUF_NAMESPACE_ID::FieldMask* unsafe_arena_release_update_mask();

  // bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_allow_missing();
  bool allow_missing() const;
  void set_allow_missing(bool value);
  private:
  bool _internal_allow_missing() const;
  void _internal_set_allow_missing(bool value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.UpdateQosVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::QosVolume* qos_volume_;
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask_;
    bool allow_missing_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class ListQosVolumesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListQosVolumesRequest) */ {
 public:
  inline ListQosVolumesRequest() : ListQosVolumesRequest(nullptr) {}
  ~ListQosVolumesRequest() override;
  explicit PROTOBUF_CONSTEXPR ListQosVolumesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListQosVolumesRequest(const ListQosVolumesRequest& from);
  ListQosVolumesRequest(ListQosVolumesRequest&& from) noexcept
    : ListQosVolumesRequest() {
    *this = ::std::move(from);
  }

  inline ListQosVolumesRequest& operator=(const ListQosVolumesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListQosVolumesRequest& operator=(ListQosVolumesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListQosVolumesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListQosVolumesRequest* internal_default_instance() {
    return reinterpret_cast<const ListQosVolumesRequest*>(
               &_ListQosVolumesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListQosVolumesRequest& a, ListQosVolumesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListQosVolumesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListQosVolumesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListQosVolumesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListQosVolumesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListQosVolumesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListQosVolumesRequest& from) {
    ListQosVolumesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListQosVolumesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListQosVolumesRequest";
  }
  protected:
  explicit ListQosVolumesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentFieldNumber = 1,
    kPageTokenFieldNumber = 3,
    kPageSizeFieldNumber = 2,
  };
  // string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_token();
  const std::string& page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* page_token);
  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(const std::string& value);
  std::string* _internal_mutable_page_token();
  public:

  // int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
  void clear_page_size();
  int32_t page_size() const;
  void set_page_size(int32_t value);
  private:
  int32_t _internal_page_size() const;
  void _internal_set_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListQosVolumesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_token_;
    int32_t page_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class ListQosVolumesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.ListQosVolumesResponse) */ {
 public:
  inline ListQosVolumesResponse() : ListQosVolumesResponse(nullptr) {}
  ~ListQosVolumesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListQosVolumesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListQosVolumesResponse(const ListQosVolumesResponse& from);
  ListQosVolumesResponse(ListQosVolumesResponse&& from) noexcept
    : ListQosVolumesResponse() {
    *this = ::std::move(from);
  }

  inline ListQosVolumesResponse& operator=(const ListQosVolumesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListQosVolumesResponse& operator=(ListQosVolumesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListQosVolumesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListQosVolumesResponse* internal_default_instance() {
    return reinterpret_cast<const ListQosVolumesResponse*>(
               &_ListQosVolumesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListQosVolumesResponse& a, ListQosVolumesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListQosVolumesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListQosVolumesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListQosVolumesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListQosVolumesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListQosVolumesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListQosVolumesResponse& from) {
    ListQosVolumesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListQosVolumesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.ListQosVolumesResponse";
  }
  protected:
  explicit ListQosVolumesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQosVolumesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
  };
  // repeated .opi_api.storage.v1.QosVolume qos_volumes = 1;
  int qos_volumes_size() const;
  private:
  int _internal_qos_volumes_size() const;
  public:
  void clear_qos_volumes();
  ::opi_api::storage::v1::QosVolume* mutable_qos_volumes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::QosVolume >*
      mutable_qos_volumes();
  private:
  const ::opi_api::storage::v1::QosVolume& _internal_qos_volumes(int index) const;
  ::opi_api::storage::v1::QosVolume* _internal_add_qos_volumes();
  public:
  const ::opi_api::storage::v1::QosVolume& qos_volumes(int index) const;
  ::opi_api::storage::v1::QosVolume* add_qos_volumes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::QosVolume >&
      qos_volumes() const;

  // string next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.ListQosVolumesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::QosVolume > qos_volumes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class GetQosVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.GetQosVolumeRequest) */ {
 public:
  inline GetQosVolumeRequest() : GetQosVolumeRequest(nullptr) {}
  ~GetQosVolumeRequest() override;
  explicit PROTOBUF_CONSTEXPR GetQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetQosVolumeRequest(const GetQosVolumeRequest& from);
  GetQosVolumeRequest(GetQosVolumeRequest&& from) noexcept
    : GetQosVolumeRequest() {
    *this = ::std::move(from);
  }

  inline GetQosVolumeRequest& operator=(const GetQosVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQosVolumeRequest& operator=(GetQosVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQosVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQosVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const GetQosVolumeRequest*>(
               &_GetQosVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetQosVolumeRequest& a, GetQosVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetQosVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQosVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQosVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetQosVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetQosVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetQosVolumeRequest& from) {
    GetQosVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetQosVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.GetQosVolumeRequest";
  }
  protected:
  explicit GetQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.GetQosVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class StatsQosVolumeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsQosVolumeRequest) */ {
 public:
  inline StatsQosVolumeRequest() : StatsQosVolumeRequest(nullptr) {}
  ~StatsQosVolumeRequest() override;
  explicit PROTOBUF_CONSTEXPR StatsQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsQosVolumeRequest(const StatsQosVolumeRequest& from);
  StatsQosVolumeRequest(StatsQosVolumeRequest&& from) noexcept
    : StatsQosVolumeRequest() {
    *this = ::std::move(from);
  }

  inline StatsQosVolumeRequest& operator=(const StatsQosVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsQosVolumeRequest& operator=(StatsQosVolumeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsQosVolumeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsQosVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const StatsQosVolumeRequest*>(
               &_StatsQosVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StatsQosVolumeRequest& a, StatsQosVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsQosVolumeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsQosVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsQosVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsQosVolumeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsQosVolumeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsQosVolumeRequest& from) {
    StatsQosVolumeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsQosVolumeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsQosVolumeRequest";
  }
  protected:
  explicit StatsQosVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsQosVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// -------------------------------------------------------------------

class StatsQosVolumeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:opi_api.storage.v1.StatsQosVolumeResponse) */ {
 public:
  inline StatsQosVolumeResponse() : StatsQosVolumeResponse(nullptr) {}
  ~StatsQosVolumeResponse() override;
  explicit PROTOBUF_CONSTEXPR StatsQosVolumeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatsQosVolumeResponse(const StatsQosVolumeResponse& from);
  StatsQosVolumeResponse(StatsQosVolumeResponse&& from) noexcept
    : StatsQosVolumeResponse() {
    *this = ::std::move(from);
  }

  inline StatsQosVolumeResponse& operator=(const StatsQosVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatsQosVolumeResponse& operator=(StatsQosVolumeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatsQosVolumeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatsQosVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const StatsQosVolumeResponse*>(
               &_StatsQosVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StatsQosVolumeResponse& a, StatsQosVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StatsQosVolumeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatsQosVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatsQosVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatsQosVolumeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatsQosVolumeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatsQosVolumeResponse& from) {
    StatsQosVolumeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatsQosVolumeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "opi_api.storage.v1.StatsQosVolumeResponse";
  }
  protected:
  explicit StatsQosVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // .opi_api.storage.v1.VolumeStats stats = 1;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::opi_api::storage::v1::VolumeStats& stats() const;
  PROTOBUF_NODISCARD ::opi_api::storage::v1::VolumeStats* release_stats();
  ::opi_api::storage::v1::VolumeStats* mutable_stats();
  void set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats);
  private:
  const ::opi_api::storage::v1::VolumeStats& _internal_stats() const;
  ::opi_api::storage::v1::VolumeStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::opi_api::storage::v1::VolumeStats* stats);
  ::opi_api::storage::v1::VolumeStats* unsafe_arena_release_stats();

  // @@protoc_insertion_point(class_scope:opi_api.storage.v1.StatsQosVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::opi_api::storage::v1::VolumeStats* stats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_middleend_5fqos_5fvolume_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// QosVolume

// string name = 1 [(.google.api.field_behavior) = OUTPUT_ONLY, (.google.api.field_behavior) = IMMUTABLE, (.google.api.resource_reference) = {
inline void QosVolume::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& QosVolume::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.QosVolume.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QosVolume::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.QosVolume.name)
}
inline std::string* QosVolume::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.QosVolume.name)
  return _s;
}
inline const std::string& QosVolume::_internal_name() const {
  return _impl_.name_.Get();
}
inline void QosVolume::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* QosVolume::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* QosVolume::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.QosVolume.name)
  return _impl_.name_.Release();
}
inline void QosVolume::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.QosVolume.name)
}

// string volume_name_ref = 2 [(.google.api.field_behavior) = REQUIRED];
inline void QosVolume::clear_volume_name_ref() {
  _impl_.volume_name_ref_.ClearToEmpty();
}
inline const std::string& QosVolume::volume_name_ref() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.QosVolume.volume_name_ref)
  return _internal_volume_name_ref();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QosVolume::set_volume_name_ref(ArgT0&& arg0, ArgT... args) {
 
 _impl_.volume_name_ref_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.QosVolume.volume_name_ref)
}
inline std::string* QosVolume::mutable_volume_name_ref() {
  std::string* _s = _internal_mutable_volume_name_ref();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.QosVolume.volume_name_ref)
  return _s;
}
inline const std::string& QosVolume::_internal_volume_name_ref() const {
  return _impl_.volume_name_ref_.Get();
}
inline void QosVolume::_internal_set_volume_name_ref(const std::string& value) {
  
  _impl_.volume_name_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* QosVolume::_internal_mutable_volume_name_ref() {
  
  return _impl_.volume_name_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* QosVolume::release_volume_name_ref() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.QosVolume.volume_name_ref)
  return _impl_.volume_name_ref_.Release();
}
inline void QosVolume::set_allocated_volume_name_ref(std::string* volume_name_ref) {
  if (volume_name_ref != nullptr) {
    
  } else {
    
  }
  _impl_.volume_name_ref_.SetAllocated(volume_name_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.volume_name_ref_.IsDefault()) {
    _impl_.volume_name_ref_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.QosVolume.volume_name_ref)
}

// .opi_api.storage.v1.Limits limits = 3 [(.google.api.field_behavior) = REQUIRED];
inline bool QosVolume::_internal_has_limits() const {
  return this != internal_default_instance() && _impl_.limits_ != nullptr;
}
inline bool QosVolume::has_limits() const {
  return _internal_has_limits();
}
inline void QosVolume::clear_limits() {
  if (GetArenaForAllocation() == nullptr && _impl_.limits_ != nullptr) {
    delete _impl_.limits_;
  }
  _impl_.limits_ = nullptr;
}
inline const ::opi_api::storage::v1::Limits& QosVolume::_internal_limits() const {
  const ::opi_api::storage::v1::Limits* p = _impl_.limits_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::Limits&>(
      ::opi_api::storage::v1::_Limits_default_instance_);
}
inline const ::opi_api::storage::v1::Limits& QosVolume::limits() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.QosVolume.limits)
  return _internal_limits();
}
inline void QosVolume::unsafe_arena_set_allocated_limits(
    ::opi_api::storage::v1::Limits* limits) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limits_);
  }
  _impl_.limits_ = limits;
  if (limits) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.QosVolume.limits)
}
inline ::opi_api::storage::v1::Limits* QosVolume::release_limits() {
  
  ::opi_api::storage::v1::Limits* temp = _impl_.limits_;
  _impl_.limits_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::Limits* QosVolume::unsafe_arena_release_limits() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.QosVolume.limits)
  
  ::opi_api::storage::v1::Limits* temp = _impl_.limits_;
  _impl_.limits_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::Limits* QosVolume::_internal_mutable_limits() {
  
  if (_impl_.limits_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::Limits>(GetArenaForAllocation());
    _impl_.limits_ = p;
  }
  return _impl_.limits_;
}
inline ::opi_api::storage::v1::Limits* QosVolume::mutable_limits() {
  ::opi_api::storage::v1::Limits* _msg = _internal_mutable_limits();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.QosVolume.limits)
  return _msg;
}
inline void QosVolume::set_allocated_limits(::opi_api::storage::v1::Limits* limits) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.limits_;
  }
  if (limits) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(limits);
    if (message_arena != submessage_arena) {
      limits = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limits, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.limits_ = limits;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.QosVolume.limits)
}

// -------------------------------------------------------------------

// Limits

// .opi_api.storage.v1.QosLimit min = 1 [(.google.api.field_behavior) = OPTIONAL];
inline bool Limits::_internal_has_min() const {
  return this != internal_default_instance() && _impl_.min_ != nullptr;
}
inline bool Limits::has_min() const {
  return _internal_has_min();
}
inline const ::opi_api::storage::v1::QosLimit& Limits::_internal_min() const {
  const ::opi_api::storage::v1::QosLimit* p = _impl_.min_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::QosLimit&>(
      ::opi_api::storage::v1::_QosLimit_default_instance_);
}
inline const ::opi_api::storage::v1::QosLimit& Limits::min() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.Limits.min)
  return _internal_min();
}
inline void Limits::unsafe_arena_set_allocated_min(
    ::opi_api::storage::v1::QosLimit* min) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_);
  }
  _impl_.min_ = min;
  if (min) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.Limits.min)
}
inline ::opi_api::storage::v1::QosLimit* Limits::release_min() {
  
  ::opi_api::storage::v1::QosLimit* temp = _impl_.min_;
  _impl_.min_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* Limits::unsafe_arena_release_min() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.Limits.min)
  
  ::opi_api::storage::v1::QosLimit* temp = _impl_.min_;
  _impl_.min_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* Limits::_internal_mutable_min() {
  
  if (_impl_.min_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::QosLimit>(GetArenaForAllocation());
    _impl_.min_ = p;
  }
  return _impl_.min_;
}
inline ::opi_api::storage::v1::QosLimit* Limits::mutable_min() {
  ::opi_api::storage::v1::QosLimit* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.Limits.min)
  return _msg;
}
inline void Limits::set_allocated_min(::opi_api::storage::v1::QosLimit* min) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.min_);
  }
  if (min) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min));
    if (message_arena != submessage_arena) {
      min = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.min_ = min;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.Limits.min)
}

// .opi_api.storage.v1.QosLimit max = 2 [(.google.api.field_behavior) = OPTIONAL];
inline bool Limits::_internal_has_max() const {
  return this != internal_default_instance() && _impl_.max_ != nullptr;
}
inline bool Limits::has_max() const {
  return _internal_has_max();
}
inline const ::opi_api::storage::v1::QosLimit& Limits::_internal_max() const {
  const ::opi_api::storage::v1::QosLimit* p = _impl_.max_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::QosLimit&>(
      ::opi_api::storage::v1::_QosLimit_default_instance_);
}
inline const ::opi_api::storage::v1::QosLimit& Limits::max() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.Limits.max)
  return _internal_max();
}
inline void Limits::unsafe_arena_set_allocated_max(
    ::opi_api::storage::v1::QosLimit* max) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_);
  }
  _impl_.max_ = max;
  if (max) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.Limits.max)
}
inline ::opi_api::storage::v1::QosLimit* Limits::release_max() {
  
  ::opi_api::storage::v1::QosLimit* temp = _impl_.max_;
  _impl_.max_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* Limits::unsafe_arena_release_max() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.Limits.max)
  
  ::opi_api::storage::v1::QosLimit* temp = _impl_.max_;
  _impl_.max_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::QosLimit* Limits::_internal_mutable_max() {
  
  if (_impl_.max_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::QosLimit>(GetArenaForAllocation());
    _impl_.max_ = p;
  }
  return _impl_.max_;
}
inline ::opi_api::storage::v1::QosLimit* Limits::mutable_max() {
  ::opi_api::storage::v1::QosLimit* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.Limits.max)
  return _msg;
}
inline void Limits::set_allocated_max(::opi_api::storage::v1::QosLimit* max) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.max_);
  }
  if (max) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(max));
    if (message_arena != submessage_arena) {
      max = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, max, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.max_ = max;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.Limits.max)
}

// -------------------------------------------------------------------

// CreateQosVolumeRequest

// .opi_api.storage.v1.QosVolume qos_volume = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool CreateQosVolumeRequest::_internal_has_qos_volume() const {
  return this != internal_default_instance() && _impl_.qos_volume_ != nullptr;
}
inline bool CreateQosVolumeRequest::has_qos_volume() const {
  return _internal_has_qos_volume();
}
inline void CreateQosVolumeRequest::clear_qos_volume() {
  if (GetArenaForAllocation() == nullptr && _impl_.qos_volume_ != nullptr) {
    delete _impl_.qos_volume_;
  }
  _impl_.qos_volume_ = nullptr;
}
inline const ::opi_api::storage::v1::QosVolume& CreateQosVolumeRequest::_internal_qos_volume() const {
  const ::opi_api::storage::v1::QosVolume* p = _impl_.qos_volume_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::QosVolume&>(
      ::opi_api::storage::v1::_QosVolume_default_instance_);
}
inline const ::opi_api::storage::v1::QosVolume& CreateQosVolumeRequest::qos_volume() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume)
  return _internal_qos_volume();
}
inline void CreateQosVolumeRequest::unsafe_arena_set_allocated_qos_volume(
    ::opi_api::storage::v1::QosVolume* qos_volume) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.qos_volume_);
  }
  _impl_.qos_volume_ = qos_volume;
  if (qos_volume) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume)
}
inline ::opi_api::storage::v1::QosVolume* CreateQosVolumeRequest::release_qos_volume() {
  
  ::opi_api::storage::v1::QosVolume* temp = _impl_.qos_volume_;
  _impl_.qos_volume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::QosVolume* CreateQosVolumeRequest::unsafe_arena_release_qos_volume() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume)
  
  ::opi_api::storage::v1::QosVolume* temp = _impl_.qos_volume_;
  _impl_.qos_volume_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::QosVolume* CreateQosVolumeRequest::_internal_mutable_qos_volume() {
  
  if (_impl_.qos_volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::QosVolume>(GetArenaForAllocation());
    _impl_.qos_volume_ = p;
  }
  return _impl_.qos_volume_;
}
inline ::opi_api::storage::v1::QosVolume* CreateQosVolumeRequest::mutable_qos_volume() {
  ::opi_api::storage::v1::QosVolume* _msg = _internal_mutable_qos_volume();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume)
  return _msg;
}
inline void CreateQosVolumeRequest::set_allocated_qos_volume(::opi_api::storage::v1::QosVolume* qos_volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.qos_volume_;
  }
  if (qos_volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qos_volume);
    if (message_arena != submessage_arena) {
      qos_volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qos_volume, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.qos_volume_ = qos_volume;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume)
}

// string qos_volume_id = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void CreateQosVolumeRequest::clear_qos_volume_id() {
  _impl_.qos_volume_id_.ClearToEmpty();
}
inline const std::string& CreateQosVolumeRequest::qos_volume_id() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume_id)
  return _internal_qos_volume_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateQosVolumeRequest::set_qos_volume_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.qos_volume_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume_id)
}
inline std::string* CreateQosVolumeRequest::mutable_qos_volume_id() {
  std::string* _s = _internal_mutable_qos_volume_id();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume_id)
  return _s;
}
inline const std::string& CreateQosVolumeRequest::_internal_qos_volume_id() const {
  return _impl_.qos_volume_id_.Get();
}
inline void CreateQosVolumeRequest::_internal_set_qos_volume_id(const std::string& value) {
  
  _impl_.qos_volume_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateQosVolumeRequest::_internal_mutable_qos_volume_id() {
  
  return _impl_.qos_volume_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateQosVolumeRequest::release_qos_volume_id() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume_id)
  return _impl_.qos_volume_id_.Release();
}
inline void CreateQosVolumeRequest::set_allocated_qos_volume_id(std::string* qos_volume_id) {
  if (qos_volume_id != nullptr) {
    
  } else {
    
  }
  _impl_.qos_volume_id_.SetAllocated(qos_volume_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.qos_volume_id_.IsDefault()) {
    _impl_.qos_volume_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.CreateQosVolumeRequest.qos_volume_id)
}

// -------------------------------------------------------------------

// DeleteQosVolumeRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void DeleteQosVolumeRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeleteQosVolumeRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteQosVolumeRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteQosVolumeRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteQosVolumeRequest.name)
}
inline std::string* DeleteQosVolumeRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.DeleteQosVolumeRequest.name)
  return _s;
}
inline const std::string& DeleteQosVolumeRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void DeleteQosVolumeRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteQosVolumeRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteQosVolumeRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.DeleteQosVolumeRequest.name)
  return _impl_.name_.Release();
}
inline void DeleteQosVolumeRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.DeleteQosVolumeRequest.name)
}

// bool allow_missing = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void DeleteQosVolumeRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool DeleteQosVolumeRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool DeleteQosVolumeRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.DeleteQosVolumeRequest.allow_missing)
  return _internal_allow_missing();
}
inline void DeleteQosVolumeRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void DeleteQosVolumeRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.DeleteQosVolumeRequest.allow_missing)
}

// -------------------------------------------------------------------

// UpdateQosVolumeRequest

// .opi_api.storage.v1.QosVolume qos_volume = 1 [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateQosVolumeRequest::_internal_has_qos_volume() const {
  return this != internal_default_instance() && _impl_.qos_volume_ != nullptr;
}
inline bool UpdateQosVolumeRequest::has_qos_volume() const {
  return _internal_has_qos_volume();
}
inline void UpdateQosVolumeRequest::clear_qos_volume() {
  if (GetArenaForAllocation() == nullptr && _impl_.qos_volume_ != nullptr) {
    delete _impl_.qos_volume_;
  }
  _impl_.qos_volume_ = nullptr;
}
inline const ::opi_api::storage::v1::QosVolume& UpdateQosVolumeRequest::_internal_qos_volume() const {
  const ::opi_api::storage::v1::QosVolume* p = _impl_.qos_volume_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::QosVolume&>(
      ::opi_api::storage::v1::_QosVolume_default_instance_);
}
inline const ::opi_api::storage::v1::QosVolume& UpdateQosVolumeRequest::qos_volume() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateQosVolumeRequest.qos_volume)
  return _internal_qos_volume();
}
inline void UpdateQosVolumeRequest::unsafe_arena_set_allocated_qos_volume(
    ::opi_api::storage::v1::QosVolume* qos_volume) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.qos_volume_);
  }
  _impl_.qos_volume_ = qos_volume;
  if (qos_volume) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateQosVolumeRequest.qos_volume)
}
inline ::opi_api::storage::v1::QosVolume* UpdateQosVolumeRequest::release_qos_volume() {
  
  ::opi_api::storage::v1::QosVolume* temp = _impl_.qos_volume_;
  _impl_.qos_volume_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::QosVolume* UpdateQosVolumeRequest::unsafe_arena_release_qos_volume() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateQosVolumeRequest.qos_volume)
  
  ::opi_api::storage::v1::QosVolume* temp = _impl_.qos_volume_;
  _impl_.qos_volume_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::QosVolume* UpdateQosVolumeRequest::_internal_mutable_qos_volume() {
  
  if (_impl_.qos_volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::QosVolume>(GetArenaForAllocation());
    _impl_.qos_volume_ = p;
  }
  return _impl_.qos_volume_;
}
inline ::opi_api::storage::v1::QosVolume* UpdateQosVolumeRequest::mutable_qos_volume() {
  ::opi_api::storage::v1::QosVolume* _msg = _internal_mutable_qos_volume();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateQosVolumeRequest.qos_volume)
  return _msg;
}
inline void UpdateQosVolumeRequest::set_allocated_qos_volume(::opi_api::storage::v1::QosVolume* qos_volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.qos_volume_;
  }
  if (qos_volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(qos_volume);
    if (message_arena != submessage_arena) {
      qos_volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qos_volume, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.qos_volume_ = qos_volume;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateQosVolumeRequest.qos_volume)
}

// .google.protobuf.FieldMask update_mask = 2 [(.google.api.field_behavior) = OPTIONAL];
inline bool UpdateQosVolumeRequest::_internal_has_update_mask() const {
  return this != internal_default_instance() && _impl_.update_mask_ != nullptr;
}
inline bool UpdateQosVolumeRequest::has_update_mask() const {
  return _internal_has_update_mask();
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateQosVolumeRequest::_internal_update_mask() const {
  const ::PROTOBUF_NAMESPACE_ID::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::FieldMask&>(
      ::PROTOBUF_NAMESPACE_ID::_FieldMask_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::FieldMask& UpdateQosVolumeRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateQosVolumeRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateQosVolumeRequest::unsafe_arena_set_allocated_update_mask(
    ::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = update_mask;
  if (update_mask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.UpdateQosVolumeRequest.update_mask)
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateQosVolumeRequest::release_update_mask() {
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateQosVolumeRequest::unsafe_arena_release_update_mask() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.UpdateQosVolumeRequest.update_mask)
  
  ::PROTOBUF_NAMESPACE_ID::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateQosVolumeRequest::_internal_mutable_update_mask() {
  
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = p;
  }
  return _impl_.update_mask_;
}
inline ::PROTOBUF_NAMESPACE_ID::FieldMask* UpdateQosVolumeRequest::mutable_update_mask() {
  ::PROTOBUF_NAMESPACE_ID::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.UpdateQosVolumeRequest.update_mask)
  return _msg;
}
inline void UpdateQosVolumeRequest::set_allocated_update_mask(::PROTOBUF_NAMESPACE_ID::FieldMask* update_mask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_mask_);
  }
  if (update_mask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(update_mask));
    if (message_arena != submessage_arena) {
      update_mask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_mask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_mask_ = update_mask;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.UpdateQosVolumeRequest.update_mask)
}

// bool allow_missing = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void UpdateQosVolumeRequest::clear_allow_missing() {
  _impl_.allow_missing_ = false;
}
inline bool UpdateQosVolumeRequest::_internal_allow_missing() const {
  return _impl_.allow_missing_;
}
inline bool UpdateQosVolumeRequest::allow_missing() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.UpdateQosVolumeRequest.allow_missing)
  return _internal_allow_missing();
}
inline void UpdateQosVolumeRequest::_internal_set_allow_missing(bool value) {
  
  _impl_.allow_missing_ = value;
}
inline void UpdateQosVolumeRequest::set_allow_missing(bool value) {
  _internal_set_allow_missing(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.UpdateQosVolumeRequest.allow_missing)
}

// -------------------------------------------------------------------

// ListQosVolumesRequest

// string parent = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void ListQosVolumesRequest::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& ListQosVolumesRequest::parent() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListQosVolumesRequest.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListQosVolumesRequest::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListQosVolumesRequest.parent)
}
inline std::string* ListQosVolumesRequest::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListQosVolumesRequest.parent)
  return _s;
}
inline const std::string& ListQosVolumesRequest::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void ListQosVolumesRequest::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* ListQosVolumesRequest::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* ListQosVolumesRequest::release_parent() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListQosVolumesRequest.parent)
  return _impl_.parent_.Release();
}
inline void ListQosVolumesRequest::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListQosVolumesRequest.parent)
}

// int32 page_size = 2 [(.google.api.field_behavior) = OPTIONAL];
inline void ListQosVolumesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline int32_t ListQosVolumesRequest::_internal_page_size() const {
  return _impl_.page_size_;
}
inline int32_t ListQosVolumesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListQosVolumesRequest.page_size)
  return _internal_page_size();
}
inline void ListQosVolumesRequest::_internal_set_page_size(int32_t value) {
  
  _impl_.page_size_ = value;
}
inline void ListQosVolumesRequest::set_page_size(int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListQosVolumesRequest.page_size)
}

// string page_token = 3 [(.google.api.field_behavior) = OPTIONAL];
inline void ListQosVolumesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListQosVolumesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListQosVolumesRequest.page_token)
  return _internal_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListQosVolumesRequest::set_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListQosVolumesRequest.page_token)
}
inline std::string* ListQosVolumesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListQosVolumesRequest.page_token)
  return _s;
}
inline const std::string& ListQosVolumesRequest::_internal_page_token() const {
  return _impl_.page_token_.Get();
}
inline void ListQosVolumesRequest::_internal_set_page_token(const std::string& value) {
  
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListQosVolumesRequest::_internal_mutable_page_token() {
  
  return _impl_.page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListQosVolumesRequest::release_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListQosVolumesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListQosVolumesRequest::set_allocated_page_token(std::string* page_token) {
  if (page_token != nullptr) {
    
  } else {
    
  }
  _impl_.page_token_.SetAllocated(page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListQosVolumesRequest.page_token)
}

// -------------------------------------------------------------------

// ListQosVolumesResponse

// repeated .opi_api.storage.v1.QosVolume qos_volumes = 1;
inline int ListQosVolumesResponse::_internal_qos_volumes_size() const {
  return _impl_.qos_volumes_.size();
}
inline int ListQosVolumesResponse::qos_volumes_size() const {
  return _internal_qos_volumes_size();
}
inline void ListQosVolumesResponse::clear_qos_volumes() {
  _impl_.qos_volumes_.Clear();
}
inline ::opi_api::storage::v1::QosVolume* ListQosVolumesResponse::mutable_qos_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListQosVolumesResponse.qos_volumes)
  return _impl_.qos_volumes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::QosVolume >*
ListQosVolumesResponse::mutable_qos_volumes() {
  // @@protoc_insertion_point(field_mutable_list:opi_api.storage.v1.ListQosVolumesResponse.qos_volumes)
  return &_impl_.qos_volumes_;
}
inline const ::opi_api::storage::v1::QosVolume& ListQosVolumesResponse::_internal_qos_volumes(int index) const {
  return _impl_.qos_volumes_.Get(index);
}
inline const ::opi_api::storage::v1::QosVolume& ListQosVolumesResponse::qos_volumes(int index) const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListQosVolumesResponse.qos_volumes)
  return _internal_qos_volumes(index);
}
inline ::opi_api::storage::v1::QosVolume* ListQosVolumesResponse::_internal_add_qos_volumes() {
  return _impl_.qos_volumes_.Add();
}
inline ::opi_api::storage::v1::QosVolume* ListQosVolumesResponse::add_qos_volumes() {
  ::opi_api::storage::v1::QosVolume* _add = _internal_add_qos_volumes();
  // @@protoc_insertion_point(field_add:opi_api.storage.v1.ListQosVolumesResponse.qos_volumes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::opi_api::storage::v1::QosVolume >&
ListQosVolumesResponse::qos_volumes() const {
  // @@protoc_insertion_point(field_list:opi_api.storage.v1.ListQosVolumesResponse.qos_volumes)
  return _impl_.qos_volumes_;
}

// string next_page_token = 2;
inline void ListQosVolumesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListQosVolumesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.ListQosVolumesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListQosVolumesResponse::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.next_page_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.ListQosVolumesResponse.next_page_token)
}
inline std::string* ListQosVolumesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.ListQosVolumesResponse.next_page_token)
  return _s;
}
inline const std::string& ListQosVolumesResponse::_internal_next_page_token() const {
  return _impl_.next_page_token_.Get();
}
inline void ListQosVolumesResponse::_internal_set_next_page_token(const std::string& value) {
  
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListQosVolumesResponse::_internal_mutable_next_page_token() {
  
  return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListQosVolumesResponse::release_next_page_token() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.ListQosVolumesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListQosVolumesResponse::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.ListQosVolumesResponse.next_page_token)
}

// -------------------------------------------------------------------

// GetQosVolumeRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void GetQosVolumeRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GetQosVolumeRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.GetQosVolumeRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetQosVolumeRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.GetQosVolumeRequest.name)
}
inline std::string* GetQosVolumeRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.GetQosVolumeRequest.name)
  return _s;
}
inline const std::string& GetQosVolumeRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GetQosVolumeRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetQosVolumeRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetQosVolumeRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.GetQosVolumeRequest.name)
  return _impl_.name_.Release();
}
inline void GetQosVolumeRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.GetQosVolumeRequest.name)
}

// -------------------------------------------------------------------

// StatsQosVolumeRequest

// string name = 1 [(.google.api.field_behavior) = REQUIRED, (.google.api.resource_reference) = {
inline void StatsQosVolumeRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StatsQosVolumeRequest::name() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsQosVolumeRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatsQosVolumeRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:opi_api.storage.v1.StatsQosVolumeRequest.name)
}
inline std::string* StatsQosVolumeRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsQosVolumeRequest.name)
  return _s;
}
inline const std::string& StatsQosVolumeRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StatsQosVolumeRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StatsQosVolumeRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StatsQosVolumeRequest::release_name() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsQosVolumeRequest.name)
  return _impl_.name_.Release();
}
inline void StatsQosVolumeRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsQosVolumeRequest.name)
}

// -------------------------------------------------------------------

// StatsQosVolumeResponse

// .opi_api.storage.v1.VolumeStats stats = 1;
inline bool StatsQosVolumeResponse::_internal_has_stats() const {
  return this != internal_default_instance() && _impl_.stats_ != nullptr;
}
inline bool StatsQosVolumeResponse::has_stats() const {
  return _internal_has_stats();
}
inline const ::opi_api::storage::v1::VolumeStats& StatsQosVolumeResponse::_internal_stats() const {
  const ::opi_api::storage::v1::VolumeStats* p = _impl_.stats_;
  return p != nullptr ? *p : reinterpret_cast<const ::opi_api::storage::v1::VolumeStats&>(
      ::opi_api::storage::v1::_VolumeStats_default_instance_);
}
inline const ::opi_api::storage::v1::VolumeStats& StatsQosVolumeResponse::stats() const {
  // @@protoc_insertion_point(field_get:opi_api.storage.v1.StatsQosVolumeResponse.stats)
  return _internal_stats();
}
inline void StatsQosVolumeResponse::unsafe_arena_set_allocated_stats(
    ::opi_api::storage::v1::VolumeStats* stats) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  _impl_.stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opi_api.storage.v1.StatsQosVolumeResponse.stats)
}
inline ::opi_api::storage::v1::VolumeStats* StatsQosVolumeResponse::release_stats() {
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsQosVolumeResponse::unsafe_arena_release_stats() {
  // @@protoc_insertion_point(field_release:opi_api.storage.v1.StatsQosVolumeResponse.stats)
  
  ::opi_api::storage::v1::VolumeStats* temp = _impl_.stats_;
  _impl_.stats_ = nullptr;
  return temp;
}
inline ::opi_api::storage::v1::VolumeStats* StatsQosVolumeResponse::_internal_mutable_stats() {
  
  if (_impl_.stats_ == nullptr) {
    auto* p = CreateMaybeMessage<::opi_api::storage::v1::VolumeStats>(GetArenaForAllocation());
    _impl_.stats_ = p;
  }
  return _impl_.stats_;
}
inline ::opi_api::storage::v1::VolumeStats* StatsQosVolumeResponse::mutable_stats() {
  ::opi_api::storage::v1::VolumeStats* _msg = _internal_mutable_stats();
  // @@protoc_insertion_point(field_mutable:opi_api.storage.v1.StatsQosVolumeResponse.stats)
  return _msg;
}
inline void StatsQosVolumeResponse::set_allocated_stats(::opi_api::storage::v1::VolumeStats* stats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stats_);
  }
  if (stats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stats));
    if (message_arena != submessage_arena) {
      stats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:opi_api.storage.v1.StatsQosVolumeResponse.stats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace storage
}  // namespace opi_api

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_middleend_5fqos_5fvolume_2eproto
